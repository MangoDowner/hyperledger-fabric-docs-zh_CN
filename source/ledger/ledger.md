# 账本

## 账本是什么?

石质分类账——但是让我们从一个更新的例子开始！你可能习惯于每月查看你的银行账户。对你来说最重要的是可用的平衡——这就是你能在当前时刻花费的东西。如果你想知道你的余额是如何得出的，那么你可以通过交易信用和借方来确定。这是一个分类账的现实例子——一个状态（您的银行余额）和一组确定它的有序交易（贷方和借方）。Hyperledger Fabric的动机来自这两个相同的关注点——呈现一组分类账状态的当前值，并捕获确定这些状态的事务的历史。让我们仔细看看超分类帐分类帐结构！

账本包含业务的当前状态，可作为交易日志。
最早的欧洲和中国账本可以追溯到将近1000年前，
而苏美尔人4000年前就有了
[石质账本](http://www.sciencephoto.com/media/686227/view/accounting-ledger-sumerian-cuneiform)。
但是让我们从一个更新的例子开始吧！

你可能习惯于每月查看你的银行账户。
对你来说最重要的是可用的平衡，这就是你能在当前时刻花费的东西。
如果你想知道你的余额是如何得出的，那么你可以通过交易信用和借方来确定。
这是一个账本的现实例子——一个状态（您的银行余额）和一组确定它的有序交易（贷方和借方）。
Hyperledger Fabric的动机来自这两个相同的关注点——呈现一组账本状态的当前值，并捕获确定这些状态的交易的历史。

让我们仔细看看Hyperledger Fabric账本结构！

## 区块链账本

区块链账本由两个截然不同的部分组成，一个是世界状态（world state），另一个是区块链。

首先，有一个**世界状态**，一个保存一组账本状态**当前值**的数据库。
世界状态使得程序很容易获得这些状态的当前值，而不必通过遍历整个交易日志来计算它们。
默认情况下，账本账状态被表示为**键-值**对，不过稍后我们将看到Hyperledger Fabric在这方面提供了灵活性。
随着状态可以被创造、更新和删除，世界状态可以频繁改变。

其次，有一个**区块链**，一个记录所有决定世界状态的变化的交易日志。
交易被收集在附加到块链的块中，使您能够理解导致当前世界状态的更改的历史。
区块链数据结构与世界状态非常不同，因为一旦写入，它就不能被修改。
它是一个**不可变**i的区块序列，每个块包含一组有序交易。

![ledger.ledger](./ledger.diagram.1.png)

*上面看到的东西表述的事情如下：账本L包括区块链B和世界状态W。区块链B确定世界状态W。*

在一个Hyperledger Fabric网络中有一个**逻辑**账本是有帮助的。
实际上，网络维护着一个账本的多个副本，通过一个叫做**共识**的过程，它与每一个副本保持一致。
**分布式账本技术**（**DLT**）一词通常与这种账本相关联，它是逻辑上单一的，但在网络中分布有许多一致的拷贝。

现在让我们更详细地检查世界状态和区块链数据结构。

## 世界状态

世界状态代表所有分类帐状态的当前值。
这是非常有用的，因为程序通常需要一个分类帐状态的当前值，而且总是很容易得到。
您不需要遍历整个区块链来计算任何分类账状态的当前值，您只需直接从世界状态获取它。

![ledger.worldstate](./ledger.diagram.3.png)

*上面看到的东西表述的事情如下：有一个 key＝CAR1和 value＝Audi 的分类帐状态。
有一个具有 key＝CAR2 的分类帐状态，它和一个更复杂的值{model:BMW, color=red, owner=Jane}。两个状态都在版本0。*

分类帐状态被用来记录通过区块链共享的应用程序信息。上面的例子显示了两辆车CAR1和CAR2的分类帐状态。
你可以看到状态有一个键和一个值。您的应用程序调用链码，该链码通过简单的API访问状态 -- 
它们使用状态键**get**, **put** 和 **delete**状态。
请注意，状态值可以是简单的(Audi...)或复杂的(type:BMW...)。

从物理上讲，世界状态是用数据库形式实现的。
这是非常有意义的，因为数据库提供了一组丰富的操作符来高效地存储和检索状态。
稍后我们将看到，Hyperledger Fabric可以被配置，使用不同的世界状态数据库来满足不同类型的状态值的需要，和应用程序所需的访问模式，例如在复杂查询中。

交易捕获到世界状态的变化，正如您所期望的，交易具有生命周期。它们是由应用程序创建的，并最终被提交到账本区块链。
[这里](../txflow.html) 将详细描述整个生命周期；
但是Hyperledger Fabric的关键设计点是，只有由一组 **背书组织** **签名** 的交易才会导致对世界状态的更新。
如果交易没有由足够的背书人签名，那么它将无法通过有效性检查，并且不会导致世界状态的更新。

您还会注意到，一个状态有一个版本号，在上面的图中，状态CAR1和CAR2处于它们的初始版本0。
每当状态改变时，状态的版本号就会递增。当状态被更新时也检查它，以确保它在创建交易时与版本匹配。
该检查确保世界状态**从与创建交易相同的期望值更改为相同的期望值**。

最后，当创建一个分类帐时，世界状态是空的。
因为表示对世界状态的有效更改的任何交易都记录在块链上，这意味着可以在任何时候从区块链重新生成世界状态。
这可以非常方便——例如，当创建peer时，自动生成世界状态。
此外，如果peer异常失败，peer重启时可以在接受交易之前重新生成世界状态。

## 区块链

现在让我们把注意力从账本世界状态转移到账本区块链。

区块链是一个交易日志，结构为相互链接的块，其中每个块包含一系列交易，每个交易表示对世界状态的查询或更新。
交易排序的确切机制在 [其他地方](../peers/peers.html#peers-and-orderers) 讨论,
重要的是，区块排序以及区块内的交易排序是在区块首次创建时建立的。

每个块的头包括区块交易的散列值，以及先前块头部的散列的副本。
通过这种方式，分类帐上的所有事务都被排序并加密地链接在一起。
这种散列和链接使得分类帐数据非常安全。
即使承载分类账的一个节点被篡改，它也不能说服所有其他节点它拥有“正确”的区块链，因为分类账分布在独立节点的网络中。

物理上，区块链总是作为文件实现，与使用数据库的世界状态相反。
这是一个明智的设计选择，因为区块链数据结构严重偏向于非常小的一组简单操作。
附加到区块链的末尾是主操作，查询是当前相对不常见的操作。

让我们更详细地看一下区块链的结构。

![ledger.blockchain](./ledger.diagram.2.png)

*上面看到的东西表述的事情如下：区块链包含块B0、B1、B2、B3。B0是区块链中的第一个块，即创世区块*

在上面的图中，我们可以看到块B2有块数据D2，它包含所有的交易：T5、T6、T7。

最重要的是，B2有一个**区块头**H2，它包含D2中所有交易的密码**散列**以及前一块B1的等效散列。
以这种方式，区是不可分割的和不可变地相互连接，这样是不是一下子就说明了术语**区块链**！

最后，如图中所示，区块链中的第一个块称为**创世区块**。
这是分类账的起点，虽然它不包含任何用户交易。
相反，它包含一个包含网络通道初始状态的配置交易（未示出）。
当我们讨论文档链中的区块链网络和[通道](../channels.html)时，我们会更详细地讨论创世区块。

## 区块

让我们仔细看看一个区块的结构。它由三个部分组成。

* **区块头**

  本部分包括三个字段，在创建块时编写。

  * **区块编号**: 区块编号：从0开始的整数（创世区块），每个新块添加到区块链上时，计数会增加1。

  * **当前区块哈希**: 当前块中包含的所有交易的哈希。

  * **前块哈希**: 块链中前一个块的散列的副本。

  ![ledger.blocks](./ledger.diagram.4.png)

  *上面看到的东西表述的事情如下：区块B2的块头H2由区块号2、当前块数据D2的散列CH2和来自前一块的散列PH1的副本（块号1）组成。*


* **区块数据**

  本节包含按顺序排列的交易列表。它是在创建块时编写的。
  这些交易具有丰富但简单的结构，我们将在本主题[后面](#Transactions)描述。

* **区块元数据**

  本节包含写入块的时间，以及区块写入器的证书、公钥和签名。
  随后，区块提交器还为每个交易添加一个有效/无效的指示符，尽管这个信息不包括在哈希中，就像创建区块时创建的那样。

## 交易

正如我们所看到的，交易捕捉到世界状态的变化。
让我们来看看包含区块中交易的详细**区块数据**结构。

![ledger.transaction](./ledger.diagram.5.png)


*上图表示内容如下: 区块B1的块数据D1中的交易T4由交易头H4、交易签名S4、交易提案P4、交易响应R4和背书列表E4组成。*

在上面的示例中，我们可以看到以下字段：

* **头部**

  本节由H4表示，它捕获有关交易的一些基本元数据，例如，相关链码的名称及其版本。

* **签名**

  本节由S4表示，包含由客户端应用程序创建的加密签名。
  这个字段用于检查交易细节是否被篡改，因为它需要应用程序的私钥来生成它。

* **提案**

  这个字段由P4表示，它编码应用程序提供给链码的输入参数，链码创建了提案的分类账更新。
  当链码运行时，该提案提供了一组输入参数，这些参数与当前世界状态结合起来确定新的世界状态。

* **响应**

  这一部分由R4表示，作为一个**读写集**（RW集）捕获世界状态的前后值。
  它是链码的输出，如果交易被成功验证，它将应用于分类账以更新世界状态。
  
* **背书**

  如E4所示，这是来自每个所需组织的签名交易响应的列表，其足以满足背书策略。
  您会注意到，虽然只有一个交易响应包含在事务中，但是会有多个背书。
  这是因为每个背书有效地编码了其组织的特定交易响应，
  这意味着不需要包含这样的交易响应：其与足够的背书不匹配，因为它将被拒绝为无效，并且不更新世界状态。
  
这结束了交易的主要领域——还有其他领域，但是这些是您需要理解的基本领域，以便对分类账数据结构有坚实的理解。

## 世界状态数据库选项

世界状态被物理地实现为数据库，以提供简单有效的存储和检索账本状态。
正如我们所看到的，分类账状态可以具有简单或复杂的值，为了适应这一点，世界状态数据库实现可以变化，从而允许有效地实现这些值。
当前状态数据库的选项包括LevelDBB和CouCHDB。

LevelDB是默认的，当账本状态是简单的键值对时尤为合适。
LealDB数据库与网络节点紧密地位于同一位置，它嵌入在相同的操作系统进程中。

当分类账状态被构造为JSON文档时，CouchDB是一个特别合适的选择，因为CouchDB支持业务交易中常见的富查询，还支持更新更丰富的数据类型。
从实现的角度来看，CouchDB在单独的操作系统进程中运行，但是在网络节点和CouchDB实例之间仍然存在1:1的关系。
所有这些都是链码不可见的。有关CouchDB的更多信息，请参见 [CouchDB as the StateDatabase](../couchdb_as_state_database.html)。

在LevelDB和CouchDB中，我们看到了Hyperledger Fabric的一个重要方面 -- 它是*可插拔*的。
世界状态数据库可以是关系数据存储、图形存储或时态数据库。
这在可以有效地访问的账本状态的类型中提供了极大的灵活性，允许Hyperledger Fabric解决许多不同类型的问题。

## 账本例子: fabcar

当我们结束账本这个话题时，让我们看一个账本例子。
如果您运行了[fabcar 账本例子](../write_first_app.html)，那么您已经创建了该分类帐。

FabCar样本应用程序创建了一套10辆车，不同颜色，制作，模型和所有者。
当前四辆汽车已经创建时，分类帐看起来是这个样子的。

![ledger.transaction](./ledger.diagram.6.png)

*上图表示事情如下： 
账本L包括世界状态W和区块链B，W包括四个状态：CAR1、CAR2、CAR3和CAR4。
B包含两个块，0和1。块1包含四个事务：T1、T2、T3、T4。*

我们可以看到，账本世界状态包含对应于CAR0、CAR1、CAR2和CAR3的状态。
CAR0的值表明它是由Tomoko拥有的蓝色丰田普锐斯，我们可以看到其他汽车类似的状态和价值。
此外，我们可以看到，所有的汽车状态都在版本号0，表明这是他们的开始版本号，他们从创建后就没有更新。

我们还可以看到，账本区块链包含两个区块。
块0是创世区块，虽然它不包含任何与汽车相关的交易。
但是，块1包含交易T1、T2、T3、T4，这些交易对应于为CAR0到CAR3创建世界状态的初始状态的事交易。
我们可以看到块1链接到块0。

我们没有在块或交易中显示其他字段，具体地说是头部和哈希值。
如果你对这些细节有兴趣，你会在文档的其他地方找到一个专门的参考主题。
它为您提供了一个完整工作的示例，其中详细介绍了整个块的交易，
但是现在，您已经实现了对Hyperledger Fabric账本的坚实概念理解。做得好！

Transaction Flow、Read-Write set语义和CouchDB作为StateDatabase主题，以深入了解事务流、并发控制和世界状态数据库。下一次

## 更多信息

更多信息请参阅 [交易流](../txflow.html),
[读-写集语义](../readwrite.html) and
[CouchDB作为状态数据库](../couchdb_as_state_database.html)主题，以深入了解交易流、并发控制和世界状态数据库。

<!--- Licensed under Creative Commons Attribution 4.0 International License
https://creativecommons.org/licenses/by/4.0/ -->
