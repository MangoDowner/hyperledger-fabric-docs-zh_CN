交易流
================

本文概述了在标准资产交换过程中发生的交易机制。该场景包括两个客户，A和B，一个购买一个销售萝卜。
他们每个人在网络上都有一个peer，通过peer发送交易并与分类帐进行交互。

.. image:: images/step0.png

**假定**

此流程假定通道被设置并运行。应用程序用户已经向组织的证书颁发机构(CA)注册和登记了，
并接收回了用于向网络进行认证的必要密码材料。

链码（包含一组代表萝卜市场初始状态的键值对）安装在对等节点上并在通道上实例化。
链码包含了定义一组交易指令的逻辑，还有萝卜的约定价格。
这一链码也制定了一个背书策略，声明了 ``peerA`` 和 ``peerB`` 都必须背书任何交易。

.. image:: images/step1.png

1. **客户端A启动交易**

发生了什么事？-客户A正在发送购买萝卜的请求。该请求以分别代表客户端A和客户端B的 ``peerA`` 和 ``peerB`` 为目标。
背书策略规定两个peer都必须对任何交易进行背书，因此请求转到 ``peerA`` 和 ``peerB``。

接下来，构建交易提案。应用程序利用支持的SDK（Node，Java，Python）并使用一个可用的API来生成事务提案。
该提案调用了链码函数的请求，以便数据能够被读取 和/或 写入分类账（即，为资产编写新的键值对）。
SDK充当将交易提案打包为适当架构的格式（gRPC上的协议缓冲区）的垫片，
并采用用户的密码凭证来为该交易提案生成唯一的签名。

.. image:: images/step2.png

2. **背书peer验证签名并执行事务**

背书peer验证
+ (1)交易提案格式良好
+ (2)过去尚未提交(重放攻击保护)
+ (3)签名有效(使用MSP)
+ (4)提交者(示例中为客户端A)被适当授权，以在通道上执行提案的相关操作（即，每个背书peer确保提交者满足频道的 *写入（Writers）* 策略）

背书peer将交易提案输入作为被调用的链码函数的参数。然后针对当前状态数据库执行链式处理，以产生事务结果，包括响应值、读集和写集。
在这一系列操作里都没有更新账本。这些值的集合以及背书peer的签名会作为“交易响应”传递回SDK，SDK解析这些返回结果进行操作。

.. note:: MSP是一个peer组件，它允许peer验证来自客户端的交易请求并签署交易结果（背书）。
          写入策略在通道创建时定义，并确定哪些用户有权向该通道提交事务。

.. image:: images/step3.png

3. **提案响应被检查**

应用程序验证peer签名，并比较提案响应，以确定提案响应是否相同。
如果链码只查询分类账，则应用程序将检查查询响应，并且通常不会将交易提交给排序服务。
如果client应用程序打算将事务提交给排序服务以更新账本，则应用程序确定在提交之前是否已经执行了指定的背书策略（即，peerA和peerB是否都认可）。
该体系结构使得：即使应用程序不检查响应或以其他方式转发未背书的交易，背书策略仍将由peer强制执行，并在提交验证阶段得到维护。

.. image:: images/step4.png

4. **客户端将背书组装到一个交易里**

应用程序在“交易消息”中向排序服务“广播”交易提案和响应。
交易将包含 读/写 集、背书peer签名和通道ID。
排序服务不需要检查交易的全部内容以便执行其操作，它只需要从网络中的所有通道接收交易，
分通并按照时间的前后顺序排列他们，并创建每个通道的事务块。

.. image:: images/step5.png

5. **交易被验证并提交**

交易块被“传递”到通道上的所有peer。
块内的交易被验证以确保执行了背书策略，并确保自交易执行生成读取集以来，读取集变量的在家啊没好呢么状态没有变化。
块中的事务会被标记为有效或无效。

.. image:: images/step6.png

6. **更新账本**

每个peer将块附加到通道链，对于每个有效交易，写入集被提交到当前状态数据库。
一个事件被发出来，以通知客户端应用程序两个消息：
+ 交易（调用）已经不可改变地附加到链中
+ 交易是被验证为有效还是无效

.. Licensed under Creative Commons Attribution 4.0 International License
   https://creativecommons.org/licenses/by/4.0/
